<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenNI2 SDK: API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png" height="44"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><span style="font-family:Georgia">OpenNI2 SDK</span>
   &#160;<span id="projectnumber", style="font-family:Georgia">v2.3.0.66</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="openni2_architecture2.png" alt="openni2_architecture2.png"/>
<div class="caption">
OpenNI2 SDK architecture</div></div>
<p> The OpenNI2 framework provides two sets of software interfaces at its core:</p>
<p>1.Application layer interface.For application layer developers, the differences in 3D sensors from different manufacturers are shielded.</p>
<p>2.Driver layer interface.As long as the 3D Sensor that implements the driver layer interface complies with the OpenNI2 protocol, it can access the device from the OpenNI2 application layer interface.</p>
<p>The OpenNI2 framework has a significant hierarchy.All API interfaces are implemented in strict accordance with this hierarchy.When you look at the code with this hierarchy in mind, it becomes clear.</p>
<p>OpenNI2 dynamically loads the device Driver through the Driver Handler module.The advantage of this is that you can separate the OpenNI2 code from the driver of the 3D Sensor and develop and maintain it as two separate projects.</p>
<p>Want to get a taste of our SDK before diving depther? Then let's get our hands dirty and write some code!</p>
<p>By the end of this tutorials you should be familiar with：</p>
<p>1.Initialization and termination of the SDK.</p>
<p>2.Reading data from the sensor.</p>
<p>3.Examining the depth information provided by the Astra's depth camera.</p>
<p>If you skipped over the section where we install the SDK and build the sample applications provided by the SDK, make sure you've at least downloaded and extracted OpenNI2 SDK to a folder you can easily access.</p>
<p>Our first step will be to set up a basic application as a starting point for progressively adding new functionality. 1.Using your favorite IDE, set up a new console application project and create a new source file called "main.cpp".</p>
<p>2.Copy the following into your main.cpp file:</p>
<div class="fragment"><div class="line">#include &lt;OpenNI.h&gt;</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">   std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">   system(&quot;pause&quot;);</div><div class="line"></div><div class="line">   return 0;</div><div class="line">}</div></div><!-- fragment --><ul>
<li><a class="el" href="_open_n_i_8h_source.html">OpenNI.h</a> must be included in all applications. It is the core of OpenNI2 SDK and is required for all C++ based OpenNI2 applications.</li>
<li>We'll use system("pause") to make sure we have an opportunity to see our handiwork before our application closes its window.</li>
</ul>
<p>To prepare OpenNI2 to do our bidding, we must first initialize OpenNI2, which is unsurprisingly done via the initialize() function. When we're ready to end our session with the SDK, we then need to give OpenNI2 an opportunity to cleanly shutdown. This is accomplished by calling the terminate function shutdown() . Add the two new lines below:</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">   // what will go here? you&#39;ll find out soon!</div><div class="line"></div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">   std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">   system(&quot;pause&quot;);</div><div class="line"></div><div class="line">   return 0;</div><div class="line">}</div></div><!-- fragment --><p>Before we get ahead of ourselves, let's take a moment to make sure that everything is as we expect it. Compile and run the application. The application should start up, print out a series of diagnostic messages to the console, and then patiently wait for you to press the "Enter" key. Once pressed, the application should gracefully exit.</p>
<blockquote class="doxtable">
<p><b>Attention</b> <br />
OpenNI2 by default logs a fair amount of diagnostic information to the console. If you do run into an issue, this can be a great place to start looking for answers. Next up: Talking to OpenNI2. </p>
</blockquote>
<p>Now that we know how to properly initialize and terminate OpenNI2, it's time to actually communicate with the OpenNI2 sensor.To do this, we use the Device class, which is an abstraction of a Device and provides the ability to connect to a Device and get configuration information about the Device and the kind of flow it supports.For now, however, we can think of Device as a physical Device and use it to control the Device.</p>
<p>Between initializing and terminating OpenNI2, we declare a Device variable.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>Now, to be sure, it looks like we've added a few lines of code to the previous step, but those lines are much more important than it looks.Simply by declaring and constructing a Device object and calling the open method of the Device object, you can instruct OpenNI2 to start connecting to the first available OpenNI2 sensor it can locate.</p>
<blockquote class="doxtable">
<p><b>Attention</b> <br />
 OpenNI2 provides an additional constructor that will allow you to connect to a specific OpenNI2 sensor. </p>
</blockquote>
<p>Time to put our Device object to good use and get some data. To do this, we'll need to read one of the streams that the OpenNI2 is providing. Streams contain the data coming from our camera packaged in packets of data called "frames". OpenNI2 currently supports a number of types of streams, including depth, color, hand, and point streams.</p>
<p>In order to access streams from the OpenNI2 and get to the frames, we'll need a VideoStream to tap into one of the streams. For the purposes of our application,we're going to focus on the depth stream. This stream gives us the distances of anything that our camera sees in pixels, and those pixels are packaged in a frame.</p>
<p>First, let's create a VideoStream using our Device.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>Next, we'll use the VideoStream depth we created in the next step to start the depth stream and get the depth data.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>We first need to retrieve the latest frame via VideoStream, and then call getData to get the depth frame data from our frame.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    int changedStreamDummy;</div><div class="line">    VideoStream* pStream = &amp;depth;</div><div class="line">    rc = OpenNI::waitForAnyStream(&amp;pStream, 1, &amp;changedStreamDummy, SAMPLE_READ_WAIT_TIMEOUT);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Wait failed! (timeout is %d ms)\n%s\n&quot;, SAMPLE_READ_WAIT_TIMEOUT, OpenNI::getExtendedError());</div><div class="line">        continue;</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.readFrame(&amp;frame);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Read failed!\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        continue;</div><div class="line">    }</div><div class="line"></div><div class="line">    if (frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_1_MM &amp;&amp; frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_100_UM)</div><div class="line">    {</div><div class="line">        printf(&quot;Unexpected frame format\n&quot;);</div><div class="line">        continue;</div><div class="line">    }</div><div class="line"></div><div class="line">    DepthPixel* pDepth = (DepthPixel*)frame.getData();</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>The obtained depth data is then printed out.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    int changedStreamDummy;</div><div class="line">    VideoStream* pStream = &amp;depth;</div><div class="line">    rc = OpenNI::waitForAnyStream(&amp;pStream, 1, &amp;changedStreamDummy, SAMPLE_READ_WAIT_TIMEOUT); </div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Wait failed! (timeout is %d ms)\n%s\n&quot;, SAMPLE_READ_WAIT_TIMEOUT, OpenNI::getExtendedError());</div><div class="line">        return 5;</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.readFrame(&amp;frame);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Read failed!\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 6;</div><div class="line">    }</div><div class="line"></div><div class="line">    if (frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_1_MM &amp;&amp; frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_100_UM)</div><div class="line">    {</div><div class="line">        printf(&quot;Unexpected frame format\n&quot;);</div><div class="line">        return 7;</div><div class="line">    }</div><div class="line"></div><div class="line">    DepthPixel* pDepth = (DepthPixel*)frame.getData();</div><div class="line"></div><div class="line">    int middleIndex = (frame.getHeight() + 1)*frame.getWidth() / 2;</div><div class="line"></div><div class="line">    printf(&quot;[%08llu] %8d\n&quot;, (long long)frame.getTimestamp(), pDepth[middleIndex]);</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>Finally, run your application to check that everything is ok.Normally, the console window that pops up prints a line of captured data frames.When the run is complete, press enter.</p>
<p>We showed you how to get a frame of data from an OpenNI2 device! Next we'll learn how to deal with a series of frames.</p>
<p>Just loop through the VideoStream's readFrame function to use the data stream.In the following example, we will take the first 100 frames from the depth stream and print the first pixel value of each frame to the console.</p>
<p>The following code is very similar to the code in our previous example, except that in addition to adding a do while loop outside the frame handling code, we also added variables to store the number of loops and the maximum number of frames we want to process.</p>
<div class="fragment"><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    int changedStreamDummy;</div><div class="line">    VideoStream* pStream = &amp;depth;</div><div class="line"></div><div class="line">   //Stores the maximum number of frames we&#39;re going to process in the loop</div><div class="line">   const int maxFramesToProcess = 100;</div><div class="line">   //Sentinel to count the number of frames that we&#39;ve processed</div><div class="line">   int count = 0;</div><div class="line"></div><div class="line">   //The frame processing loop</div><div class="line">    do{</div><div class="line">        rc = OpenNI::waitForAnyStream(&amp;pStream, 1, &amp;changedStreamDummy, SAMPLE_READ_WAIT_TIMEOUT); </div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Wait failed! (timeout is %d ms)\n%s\n&quot;, SAMPLE_READ_WAIT_TIMEOUT, OpenNI::getExtendedError());</div><div class="line">            continue;</div><div class="line">        }</div><div class="line"></div><div class="line">        rc = depth.readFrame(&amp;frame);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Read failed!\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            continue;</div><div class="line">        }</div><div class="line"></div><div class="line">        if (frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_1_MM &amp;&amp; frame.getVideoMode().getPixelFormat() != PIXEL_FORMAT_DEPTH_100_UM)</div><div class="line">        {</div><div class="line">            printf(&quot;Unexpected frame format\n&quot;);</div><div class="line">            continue;</div><div class="line">        }</div><div class="line"></div><div class="line">        DepthPixel* pDepth = (DepthPixel*)frame.getData();</div><div class="line"></div><div class="line">        printf(&quot;[%08llu] %8d\n&quot;, (long long)frame.getTimestamp(), pDepth[0]);</div><div class="line"></div><div class="line">        count++;</div><div class="line">    }while (count &lt; maxFramesToProcess);</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>Compile and run. While the program is running and the OpenNI2 is focused on you, move around a bit and watch the data values on the frames change.</p>
<p>Achievement get! You've just made your first OpenNI2 application! If you haven't had your fill of fun with OpenNI2 yet, continue on to Retrieving Stream Data.</p>
<p>The OpenNI2 SDK supports three data flow types.These data streams are generated by the sensor and passed through the SDK to the application.You can select the appropriate data flow according to your needs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stream Type  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SENSOR_COLOR  </td><td class="markdownTableBodyLeft">RGB pixel data from the sensor. The data array included in each ColorFrame contains values ranging from 0-255 for each color component of each pixel. Never start it when InfraredStream is started.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">SENSOR_DEPTH  </td><td class="markdownTableBodyLeft">Depth data from the sensor. The data array included in each DepthFrame contains values in millimeters for each pixel within the sensor's field of view.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SENSOR_IR  </td><td class="markdownTableBodyLeft">IR data from the sensor.   </td></tr>
</table>
<p>Two methods are provided by the OpenNI2 SDK to get stream data. Depending on your particular use case and the complexity of your application, one method may be better suited than the other.</p>
<p><b>Polling</b></p>
<p>The polling method to get the frame data is the most direct way to get the stream data, and is used in the Hello World tutorial.To use this method, you simply call OpenNI::waitForAnyStream and read the stream data through the VideoStream::readFrame() method.If new data is generated, the readFrame() method provides a VideoFrameRef that can access the newly generated video frames.If no new frames are generated, the OpenNI::waitForAnyStream method blocks until a new frame is generated.If you want to limit the time the SDK waits for a new frame to arrive, you can pass the timeout as a parameter to the OpenNI::waitForAnyStream function.</p>
<div class="fragment"><div class="line">Status rc = OpenNI::initialize();</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 1;</div><div class="line">}</div><div class="line"></div><div class="line">Device device;</div><div class="line">rc = device.open(ANY_DEVICE);</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 2;</div><div class="line">}</div><div class="line"></div><div class="line">VideoStream depth;</div><div class="line"></div><div class="line">if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">{</div><div class="line">    rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 3;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">rc = depth.start();</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 4;</div><div class="line">}</div><div class="line"></div><div class="line">int changedStreamDummy;</div><div class="line">VideoStream* pStream = &amp;depth;</div><div class="line">rc = OpenNI::waitForAnyStream(&amp;pStream, 1, &amp;changedStreamDummy, SAMPLE_READ_WAIT_TIMEOUT); </div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Wait failed! (timeout is %d ms)\n%s\n&quot;, SAMPLE_READ_WAIT_TIMEOUT, OpenNI::getExtendedError());</div><div class="line">    return 5;</div><div class="line">}</div><div class="line"></div><div class="line">rc = depth.readFrame(&amp;frame);</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Read failed!\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 6;</div><div class="line">}</div></div><!-- fragment --><p><b>Event</b></p>
<p>Getting frame data using an event-based approach requires a small amount of additional setup, but allows developers to delegate the processing of frames to one or more separate classes.OpenNI2 SDK provides a named VideoStream: : NewFrameListener abstract classes, this class implements a only called NewFrameListener: : onNewFrame function.Once the VideoStream stream has a data frame and ready to be processed, immediately call NewFrameListener: : onNewFrame function.</p>
<p>An example of a listener class derived from NewFrameListener:</p>
<div class="fragment"><div class="line">class PrintCallback : public VideoStream::NewFrameListener</div><div class="line">{</div><div class="line">public:</div><div class="line">    void onNewFrame(VideoStream&amp; stream)</div><div class="line">    {</div><div class="line">        stream.readFrame(&amp;m_frame);</div><div class="line">    }</div><div class="line">private:</div><div class="line">    VideoFrameRef m_frame;</div><div class="line">};</div></div><!-- fragment --><p>Defines a listener class, in order to use it, must instantiate the listener in the application, and then use the VideoStream: : addNewFrameListener function will be added to the VideoStream.</p>
<p>Example use of listener:</p>
<div class="fragment"><div class="line">Status rc = OpenNI::initialize();</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 1;</div><div class="line">}</div><div class="line"></div><div class="line">Device device;</div><div class="line">rc = device.open(ANY_DEVICE);</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 2;</div><div class="line">}</div><div class="line"></div><div class="line">VideoStream depth;</div><div class="line"></div><div class="line">if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">{</div><div class="line">    rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 3;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">rc = depth.start();</div><div class="line">if (rc != STATUS_OK)</div><div class="line">{</div><div class="line">    printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">    return 4;</div><div class="line">}</div><div class="line"></div><div class="line">PrintCallback depthPrinter;</div><div class="line"></div><div class="line">// Register to new frame</div><div class="line">depth.addNewFrameListener(&amp;depthPrinter);</div><div class="line"></div><div class="line">// Wait while we&#39;re getting frames through the printer</div><div class="line">while (true)</div><div class="line">{</div><div class="line">    Sleep(100);</div><div class="line">}</div></div><!-- fragment --><p>In fact, the while loop in the above code does not need to be executed all the time and needs to exit the loop when the application closes or another application-specific event occurs.</p>
<p>For a more practical example of a listener, continue reading the Event Based Read.</p>
<p>Thirsting for more knowledge after finishing the Hello World Tutorial? Now that you've mastered some of the basic concepts of OpenNI2 SDK, let's read the depth stream from our OpenNI2 using another feature.</p>
<p>By the end of this tutorial you should be familiar with:</p>
<ul>
<li>The purpose of the NewFrameListener class</li>
<li>How to define a NewFrameListener</li>
<li>Using a NewFrameListener to process a depth stream.</li>
</ul>
<p>Before We Begin</p>
<p>1.Download and decompress the latest OpenNI2 SDK, if you haven't already.</p>
<p>2.Using your favorite IDE, set up a new console application project and create a new source file called "main.cpp".</p>
<p>3.Copy the following into yourmain.cpp file:</p>
<div class="fragment"><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;OpenNI.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    // More of your code will go here</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>In the Hello World tutorial, we wait for a data frame by looping OpenNI::waitForAnyStream, and VideoStream's readFrame function reads a data frame.In simple cases, such as our Hello World application, this solution works very well.But what if we read and process data frames from multiple videostreams at the same time?In all of these cases, the code in the loop can quickly become complex, messy, and cumbersome.</p>
<p>To address these issues, the OpenNI2 SDK provides a framework for defining and creating the NewFrameListener.The NewFrameListener has a function called onNewFrame that is called when you are ready to process a new frame of a particular type.So instead of looping over OpenNI::waitForAnyStream, our listener automatically passes the latest frame to the onNewFrame function as soon as the frame is ready.</p>
<p>To use the NewFrameListener in our example.</p>
<p>1.We need to define a listener class that implements NewFrameListener.This listener class will enable us to access the actual frames from the OpenNI2 sensor.We will get those frames in the onNewFrame function.Copy the following code below the #include directive and above the main function main:</p>
<div class="fragment"><div class="line">using namespace openni;</div><div class="line"></div><div class="line">void analyzeFrame(const VideoFrameRef&amp; frame)</div><div class="line">{</div><div class="line">    DepthPixel* pDepth;</div><div class="line"></div><div class="line">    int middleIndex = (frame.getHeight()+1)*frame.getWidth()/2;</div><div class="line"></div><div class="line">    switch (frame.getVideoMode().getPixelFormat())</div><div class="line">    {</div><div class="line">    case PIXEL_FORMAT_DEPTH_1_MM:</div><div class="line">    case PIXEL_FORMAT_DEPTH_100_UM:</div><div class="line">        pDepth = (DepthPixel*)frame.getData();</div><div class="line">        printf(&quot;[%08llu] %8d\n&quot;, (long long)frame.getTimestamp(),</div><div class="line">            pDepth[middleIndex]);</div><div class="line">        break;</div><div class="line"></div><div class="line">    default:</div><div class="line">        printf(&quot;Unknown format\n&quot;);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">class DepthFrameListener : public VideoStream::NewFrameListener</div><div class="line">{</div><div class="line">public:</div><div class="line">    void onNewFrame(VideoStream&amp; stream)</div><div class="line">    {</div><div class="line">        stream.readFrame(&amp;m_frame);</div><div class="line"></div><div class="line">        analyzeFrame(m_frame);</div><div class="line">    }</div><div class="line">private:</div><div class="line">    VideoFrameRef m_frame;</div><div class="line">};</div></div><!-- fragment --><blockquote class="doxtable">
<p>Note <br />
 The only required function is the onNewFrame function. The other functions in this class support what we do within that function. </p>
</blockquote>
<p>With the DepthFrameListener defined, let's construct our listener in the main function and add it to the VideoStream that we created in a previous step.</p>
<div class="fragment"><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;OpenNI.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    DepthFrameListener depthPrinter;</div><div class="line"></div><div class="line">    // Register to new frame</div><div class="line">    depth.addNewFrameListener(&amp;depthPrinter);</div><div class="line"></div><div class="line">    // More of your code will go here</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>We have Device turned on and are listening for the depth frames flowing in through Device's VideoStream.</p>
<p>But the above program, may not even a data frame processing has ended.So we add a loop, and we don't stop the loop until a keypad button is clicked.To capture keystroke events, we introduce a header file #include &lt;conio. H&gt;, and defines the wasKeyboardHit function. In addition, the listener needs to be removed by calling removeNewFrameListener before the program finishes.</p>
<div class="fragment"><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;OpenNI.h&quot;</div><div class="line">#include &lt;conio.h&gt;</div><div class="line"></div><div class="line">int wasKeyboardHit()</div><div class="line">{</div><div class="line">    return (int)_kbhit();</div><div class="line">}</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    Status rc = OpenNI::initialize();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Initialize failed\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    Device device;</div><div class="line">    rc = device.open(ANY_DEVICE);</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t open device\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    VideoStream depth;</div><div class="line"></div><div class="line">    if (device.getSensorInfo(SENSOR_DEPTH) != NULL)</div><div class="line">    {</div><div class="line">        rc = depth.create(device, SENSOR_DEPTH);</div><div class="line">        if (rc != STATUS_OK)</div><div class="line">        {</div><div class="line">            printf(&quot;Couldn&#39;t create depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">            return 3;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    rc = depth.start();</div><div class="line">    if (rc != STATUS_OK)</div><div class="line">    {</div><div class="line">        printf(&quot;Couldn&#39;t start the depth stream\n%s\n&quot;, OpenNI::getExtendedError());</div><div class="line">        return 4;</div><div class="line">    }</div><div class="line"></div><div class="line">    DepthFrameListener depthPrinter;</div><div class="line"></div><div class="line">    // Register to new frame</div><div class="line">    depth.addNewFrameListener(&amp;depthPrinter);</div><div class="line"></div><div class="line">    // Wait while we&#39;re getting frames through the printer</div><div class="line">    while (!wasKeyboardHit())</div><div class="line">    {</div><div class="line">        Sleep(100);</div><div class="line">    }</div><div class="line"></div><div class="line">    depth.removeNewFrameListener(&amp;depthPrinter);</div><div class="line"></div><div class="line">    depth.stop();</div><div class="line">    depth.destroy();</div><div class="line">    device.close();</div><div class="line">    OpenNI::shutdown();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;hit enter to exit program&quot; &lt;&lt; std::endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>Let's compile and run our solution. After you've watched some depth frame information print to the console, revel in the knowledge that you've mastered the listener along with other core OpenNI2 SDK functionality. Now, go forth, let your imagination run wild and use OpenNI2 SDK to do all sorts of innovative things!</p>
<div class="fragment"><div class="line">What&#39;s New</div><div class="line">==========</div><div class="line">v2.3.0.66 2020/12/31</div><div class="line">1 Support selinux, solve the security permission restriction problem of Android system.</div><div class="line">2 Release the NIViewer&#39;s Android source code.</div><div class="line">3 Fix some bugs,include LDP problem of some module.</div><div class="line">--------------------------------------------------------</div><div class="line">v2.3.0.65 2020/10/15</div><div class="line">1 Support Astra+;</div><div class="line">2 Add fan switch interface for Astra+;</div><div class="line">3 Add RGB SN interface for Astra+,so we can use this interface to read SN of RGB; </div><div class="line">4 Add cross cargo module;</div><div class="line">5 Add interface that return resolution list based on PID.</div><div class="line">-------------------------</div><div class="line">v2.3.0.63 2020/04/15 First version ready for external use.</div></div><!-- fragment --></div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
  <strong>© 2020 <a href="https://orbbec3d.com/">Orbbec 3D</a></strong> All Rights Reserved.
</small></address>
</body>
</html>
